[
  {
    "objectID": "posts/Hintzman1/index.html",
    "href": "posts/Hintzman1/index.html",
    "title": "Reproducing Hintzman’s MINERVA (Part 1)",
    "section": "",
    "text": "#Generating category prototypes and exemplars\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n\n\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nset.seed(30)\nvalues <- c(rep(-1, 50), rep(1, 50))\nprotoA <- sample(values, 23, replace = TRUE)\nprotoB <- sample(values, 23, replace = TRUE)\nprotoC <- sample(values, 23, replace = TRUE)\nfeat_index <- 11:23\n\ndistort_low <- function(x) {\n  change_index <- sample(feat_index, 2)\n  x_new <- x\n  x_new[change_index[1]] <- x_new[change_index[1]] * -1\n  x_new[change_index[2]] <- x_new[change_index[2]] * -1\n  return(x_new)\n}\ndistort_high <- function(x) {\n  change_index <- sample(feat_index, 4)\n  x_new <- x\n  x_new[change_index[1]] <- x_new[change_index[1]] * -1\n  x_new[change_index[2]] <- x_new[change_index[2]] * -1\n  x_new[change_index[3]] <- x_new[change_index[3]] * -1\n  x_new[change_index[4]] <- x_new[change_index[4]] * -1\n  return(x_new)\n}\n\nlow_A1 <- distort_low(protoA)\nlow_A2 <- distort_low(protoA)\nlow_A3 <- distort_low(protoA)\nlow_B1 <- distort_low(protoB)\nlow_B2 <- distort_low(protoB)\nlow_B3 <- distort_low(protoB)\nlow_B4 <- distort_low(protoB)\nlow_B5 <- distort_low(protoB)\nlow_B6 <- distort_low(protoB)\nlow_C1 <- distort_low(protoC)\nlow_C2 <- distort_low(protoC)\nlow_C3 <- distort_low(protoC)\nlow_C4 <- distort_low(protoC)\nlow_C5 <- distort_low(protoC)\nlow_C6 <- distort_low(protoC)\nlow_C7 <- distort_low(protoC)\nlow_C8 <- distort_low(protoC) \nlow_C9 <- distort_low(protoC)\n\nlow_C_full <- rbind(low_C1, low_C2, low_C3, low_C4, low_C5, low_C6, low_C7, low_C8, low_C9)\n\nhigh_A1 <- distort_high(protoA)\nhigh_B1 <- distort_high(protoB)\nhigh_C1 <- distort_high(protoC)\n\nThe code works, but is very inelegant and requires a lot of copy and pasting. There has to be a way to automate this with a function so that I can simulate this whole thing 20 times.\n\nindexC_high <- seq(1, 23, 1)\nfor(i in 1:9) {\n  temp <- distort_high(protoC)\n  indexC_high <- rbind(indexC_high, temp)\n}\n\nThis is faster, but still requires specifying the variable to store it in, the number of exemplars, the function and the prototype. Attempts to create a function to automate this failed, as the dataframe returned (e.g. indexC_high) was unchanged."
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "I’m a millennial and technology is not my forte.\nIn spite of that, here is my attempt at a blog record of things I’ve learned. Here’s to jumping off the deep end…"
  },
  {
    "objectID": "posts/TechSetUp/index.html",
    "href": "posts/TechSetUp/index.html",
    "title": "Setting up the Techymabobs",
    "section": "",
    "text": "Matt introduced me to a ton of new software to download and familiarize myself with.\nQuarto blog\nI updated both R and RStudio, and the Quarto blog works as intended. However, remember to NOT rename the index.qmd etc. files, as that interferes with the seamless rendering process and the blog will not be updated as you render.\nDragging and dropping images still does not work. It would be really convenient if this could be rectified.\nSometime in the near future, I need to refresh my Rmarkdown code wrt to stylistic features, so I can do away with the default blog visuals.\nZotero\nI downloaded Zotero and the Safari plugin, and it seems to work fine. It syncs with R and with Microsoft Word, and my brief tests don’t raise any issues.\nI do have to note that most articles downloaded from Google Scholar do not contain DOI information, so this is something I still have to add in manually.\nGithub Desktop\nDownloading this was the easy part. Committing to changes and publishing/pushing was also not too difficult to figure out.\nThe only roadblock I’ve faced thus far is obtaining the blog URL. After setting the output directory to docs, I get a message saying that the pages failed to be built? I’m not sure how to fix this.\nI’ve noticed also that, while I’ve downloaded Github Desktop, I can’t seem to get the “Create a git repository” option when I start a new project in RStudio. An hour of Googling and troubleshooting has gotten me nowhere, so I’m stumped for now."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Computational Cognition",
    "section": "",
    "text": "A blog record of a computational cognition journey\n\n\n\n\n\n\n\n\n  \n\n\n\n\nReproducing Hintzman’s MINERVA (Part 3)\n\n\n\n\n\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nFeb 1, 2023\n\n\nBram Goh\n\n\n\n\n\n\n  \n\n\n\n\nReproducing Hintzman’s MINERVA (Part 2)\n\n\n\n\n\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nJan 31, 2023\n\n\nBram Goh\n\n\n\n\n\n\n  \n\n\n\n\nReproducing Hintzman’s MINERVA (Part 1)\n\n\n\n\n\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nJan 26, 2023\n\n\nBram Goh\n\n\n\n\n\n\n  \n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\n\nmisc\n\n\n\n\n\n\n\n\n\n\n\nJan 26, 2023\n\n\nBram Goh\n\n\n\n\n\n\n  \n\n\n\n\nSetting up the Techymabobs\n\n\n\n\n\n\n\ntech\n\n\n\n\n\n\n\n\n\n\n\nJan 26, 2023\n\n\nBram Goh\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/Hintzman2/index.html",
    "href": "posts/Hintzman2/index.html",
    "title": "Reproducing Hintzman’s MINERVA (Part 2)",
    "section": "",
    "text": "Generating traces and calculating the echo\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n\n\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nset.seed(30)\nnum_feat <- 13\nnum_name <- 10\nnum_trace <- num_name + num_feat\nvalues <- c(rep(1, 50), rep(-1, 50))\n\n# Generating exemplars with distortions\n\ngen_exemp <- function(num_exemp, num_distort) {\n  \n  name <- sample(values, num_name)\n  name_copies <- matrix(rep(name, num_exemp), nrow = num_exemp, ncol = num_name, byrow = TRUE)\n  \n  feat_raw <- t(replicate(num_exemp, sample(values, num_feat)))\n  feat_filter <- t(replicate(n = num_exemp, sample(c(rep(1, num_feat - num_distort), rep(-1, num_distort)), num_feat)))\n  \n  feat_final <- feat_raw * feat_filter\n\n  exemp <- cbind(name_copies, feat_final)\n  \n  return(exemp)\n}\n\n\nempty_feat <- rep(0, num_feat)\n\nabstraction <- function(n1, n2, n3, num_distort) {\n\n# Generating traces and probes\na <- gen_exemp(n1, num_distort)\nprobe_a <- c(a[1, 1:num_name], empty_feat)\nb <- gen_exemp(n2, num_distort)\nprobe_b <- c(b[1, 1:num_name], empty_feat)\nc <- gen_exemp(n3, num_distort)\nprobe_c <- c(c[1, 1:num_name], empty_feat)\n  \nsm <- rbind(a, b, c)\n  \n# Echo activation function\necho_activation <- function(probe, sec_mem) {\n  e_int <- c()\n      for(i in 1:nrow(sec_mem)){\n          n_rel <- 0\n          temp_sim <- 0\n              for(j in 1:num_trace){\n                   current <- probe[j] * sec_mem[i, j]\n                   temp_sim <- current + temp_sim\n                          if(probe[j] != 0 & sec_mem[i, j] != 0) {\n                                     n_rel <- n_rel + 1\n      }\n}\ntrace_sim <- temp_sim/n_rel\ntrace_act <- trace_sim^3\ne_int <- c(e_int, trace_act)\n      }\n  return(e_int)\n}\n\nactivs_a <- echo_activation(probe_a, sm)\nactivs_b <- echo_activation(probe_b, sm)\nactivs_c <- echo_activation(probe_c, sm)\n\n# Echo content function\n\necho_content <- function(acts, sec_mem) {\n  e_cont <- c()\n  for(j in 1:num_trace){\n    temp_cont <- 0\n    for(i in 1:nrow(sec_mem)){\n      current <- acts[i] * sec_mem[i, j]\n      temp_cont <- current + temp_cont\n    }\n    e_cont <- c(e_cont, temp_cont)\n  }\n  return(e_cont)\n}\n\n# Calculating echo intensity and probe-echo correlations\necho_a <- round(echo_content(activs_a, sm), 3)\ncor_a <- cor(probe_a, echo_a)\nint_a <- sum(activs_a)\necho_b <- round(echo_content(activs_b, sm), 3)\ncor_b <- cor(probe_b, echo_b)\nint_b <- sum(activs_b)\necho_c <- round(echo_content(activs_c, sm), 3)\ncor_c <- cor(probe_c, echo_c)\nint_c <- sum(activs_c)\n\ndf <- data.frame(corr = c(cor_a, cor_b, cor_c), intensity = c(int_a, int_b, int_c))\nrownames(df) <- c(\"catA\", \"catB\", \"catC\")\nreturn(df)\n}\n\nI am close to replicating the Abstraction exercise in Hintzman (1986). I’ve made a mistake, however, as I am supposed to calculate prototype-echo correlations, not probe-echo correlations. I’ll need to rectify this, as well as amend the code to allow for 20 simulations, so that I can calculate mean prototype-echo correlations for the 3-, 6-, and 9-exemplar categories."
  },
  {
    "objectID": "posts/Hintzman3/index.html",
    "href": "posts/Hintzman3/index.html",
    "title": "Reproducing Hintzman’s MINERVA (Part 3)",
    "section": "",
    "text": "First (completed) attempt at the Abstraction exercise\n\nlibrary(tidyverse)\n\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n\n\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n\n\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n\nset.seed(30)\nnum_feat <- 13\nnum_name <- 10\nnum_trace <- num_name + num_feat\nvalues <- c(rep(1, 50), rep(-1, 50))\n\nempty_feat <- rep(0, num_feat)\n\nabstraction <- function(num_a, num_b, num_c, num_distort) {\n\n# Generating prototype\n  \ngen_proto <- function() {\n   proto <- sample(values, num_trace, replace = TRUE)\n   return(proto)\n}\n\nproto_a <- gen_proto()\nproto_b <- gen_proto()\nproto_c <- gen_proto()\n\n# Generating exemplars with distortions\n\ngen_exemp <- function(proto, num_exemp, num_distort) {\n  \n  proto_copies <- matrix(rep(proto, num_exemp), nrow = num_exemp, ncol = num_trace, byrow = TRUE)\n  \n  name_matrix_ones <- matrix(1, nrow = num_exemp, ncol = num_name)\n  feat_matrix_distort <- t(replicate(n = num_exemp, sample(c(rep(1, num_feat - num_distort), rep(-1, num_distort)), num_feat)))\n  distort_filter <- cbind(name_matrix_ones, feat_matrix_distort)\n\n  exemp <- proto_copies * distort_filter\n  return(exemp)\n}\n  \n# Generating traces and probes\na <- gen_exemp(proto_a, num_a, num_distort)\nprobe_a <- c(a[1, 1:num_name], empty_feat)\nb <- gen_exemp(proto_b, num_b, num_distort)\nprobe_b <- c(b[1, 1:num_name], empty_feat)\nc <- gen_exemp(proto_c, num_c, num_distort)\nprobe_c <- c(c[1, 1:num_name], empty_feat)\n  \nsm <- rbind(a, b, c)\n  \n# Echo activation function\necho_activation <- function(probe, sec_mem) {\n  e_activs <- c()\n      for(i in 1:nrow(sec_mem)){\n          n_rel <- 0\n          temp_sim <- 0\n              for(j in 1:num_trace){\n                   current <- probe[j] * sec_mem[i, j]\n                   temp_sim <- current + temp_sim\n                          if(probe[j] != 0 & sec_mem[i, j] != 0) {\n                                     n_rel <- n_rel + 1\n      }\n}\ntrace_sim <- temp_sim/n_rel\ntrace_act <- trace_sim^3\ne_activs <- c(e_activs, trace_act)\n      }\n  return(e_activs)\n}\n\nactivs_a <- echo_activation(probe_a, sm)\nactivs_b <- echo_activation(probe_b, sm)\nactivs_c <- echo_activation(probe_c, sm)\n\n# Echo content function\n\necho_content <- function(acts, sec_mem) {\n  e_cont <- c()\n  for(j in 1:num_trace){\n    temp_cont <- 0\n    for(i in 1:nrow(sec_mem)){\n      current <- acts[i] * sec_mem[i, j]\n      temp_cont <- current + temp_cont\n    }\n    e_cont <- c(e_cont, temp_cont)\n  }\n  return(e_cont)\n}\n\n# Calculating echo intensity and probe-echo correlations\necho_a <- round(echo_content(activs_a, sm), 3)\ncor_a <- cor(proto_a, echo_a)\nint_a <- sum(activs_a)\necho_b <- round(echo_content(activs_b, sm), 3)\ncor_b <- cor(proto_b, echo_b)\nint_b <- sum(activs_b)\necho_c <- round(echo_content(activs_c, sm), 3)\ncor_c <- cor(proto_c, echo_c)\nint_c <- sum(activs_c)\n\ndf <- data.frame(corr = c(cor_a, cor_b, cor_c), intensity = c(int_a, int_b, int_c))\nrownames(df) <- c(\"catA\", \"catB\", \"catC\")\nreturn(df)\n}\n\nI had to rework the code so that the prototypes were actually the basis for the distorted exemplars. The code seems to work and generate the intended outcomes, but I’ll need to verify it with Matt.\nI’ll also need to ask if there is a way to return multiple outputs from this function i.e. for each of the 3 categories, I’ll need the prototype, the echo, the prototype-echo correlation, and the echo intensity. Perhaps returning a list would work?\nThe next step is to produce graphs like the ones in Hintzman (1986) comparing prototypes to echos."
  }
]