---
title: "Hintzman's (1988) MINERVA (Part 2)"
author: "Bram Goh"
date: "2023-02-16"
categories: [code]
image: "frequency_discrim.png"
---

# Absolute Frequency Judgments

## Code from previous exercise

```{r}
library(tidyverse)
set.seed(30)

# Activation function (borrowed from Matt) for a single probe (i.e. a probe vector)

get_activations_3 <- function(probe, mem) {
  
  as.numeric(((probe %*% t(mem)) / rowSums(t((probe == 0) * t(mem == 0)) == 0))^3)
}

# Item generation function (borrowed from Matt)

generate_item <- function(item_size=20,prob=c(1/3,1/3,1/3)){
  item <- sample(c(1,0,-1),
           size = item_size,
           replace = TRUE,
           prob = prob)
  return(item)
}

# Item matrix (original, before applying learning rate) function

gen_item_matrix <- function(matrix_size = 20, item_size = 20, prob = c(1/3, 1/3, 1/3)) {
  item_matrix <- t(replicate(n = matrix_size, generate_item(item_size = item_size, prob = prob)))
  return(item_matrix)
}

# Form secondary memory -- create encoded matrix (i.e. apply learning rate) and input varying frequencies of items

gen_secondary_mem <- function(item_matrix, l_value = .5, max_num_of_copies = 5, num_of_traces_per_freq = 4) {
  learning_matrix <- replicate(n = ncol(item_matrix), sample(c(0,1), size = nrow(item_matrix), prob = c(1 - l_value, l_value), replace = TRUE))
  encoded_matrix <- item_matrix * learning_matrix
  
  freq_multiplier <- c()
  for (i in 1:max_num_of_copies) {
    current_multiplier <- rep(i, num_of_traces_per_freq)
    freq_multiplier <- c(freq_multiplier, current_multiplier)
  }
  secondary_memory <- c()
  for(i in 1:nrow(encoded_matrix)) {
    current_rows <- matrix(encoded_matrix[i , ], nrow = freq_multiplier[i], ncol = ncol(encoded_matrix), byrow = TRUE)
    secondary_memory <- rbind(secondary_memory, current_rows)
  }
 return(secondary_memory)
}

# Form probe matrix i.e. item_matrix + 4 more random items

gen_probes <- function(item_matrix, prob = c(1/3, 1/3, 1/3), max_num_of_copies = 5, num_of_traces_per_freq = 4) {
  random_items <- t(replicate(n = num_of_traces_per_freq, generate_item(item_size = ncol(item_matrix), prob = prob)))
  probe_matrix <- rbind(random_items, item_matrix)
  return(probe_matrix)
}

# Calculate activations for multiple probes

calc_activs_for_mult_probes <- function(probe_matrix, secondary_memory) {
  activations_matrix <- c()
  for(i in 1:nrow(probe_matrix)) {
    current_activs <- get_activations_3(probe_matrix[i, ], secondary_memory)
    activations_matrix <- rbind(activations_matrix, current_activs)
  }
  return(activations_matrix)
}

# Convert activations matrix to transformed intensity matrix ready for plotting

convert_to_intensity_mat <- function(activations_matrix, max_num_of_copies = 5, num_of_traces_per_freq = 4) {
  intensity_vector <- rowSums(activations_matrix)
  intensity_matrix <- matrix(intensity_vector, nrow = max_num_of_copies + 1, ncol = num_of_traces_per_freq, byrow = TRUE)
  return(intensity_matrix)
}
```

```{r}
# Overall simulation function

sim_intensity_once <- function(matrix_size = 20, item_size = 20, prob = c(1/3, 1/3, 1/3), l_value = .5, max_num_of_copies = 5, num_of_traces_per_freq = 4) {
  item_matrix <- gen_item_matrix(matrix_size = matrix_size, item_size = item_size, prob = prob)
  secondary_memory <- gen_secondary_mem(item_matrix, l_value = l_value, max_num_of_copies = max_num_of_copies, num_of_traces_per_freq = num_of_traces_per_freq)
  probe_matrix <- gen_probes(item_matrix, prob = prob, max_num_of_copies = max_num_of_copies, num_of_traces_per_freq = num_of_traces_per_freq)
  activations_matrix <- calc_activs_for_mult_probes(probe_matrix, secondary_memory)
  intensity_matrix <- convert_to_intensity_mat(activations_matrix, max_num_of_copies = max_num_of_copies, num_of_traces_per_freq = num_of_traces_per_freq)
  return(intensity_matrix)
}

sim_intensity_multiple <- function(n_of_sim, matrix_size = 20, item_size = 20, prob = c(1/3, 1/3, 1/3), l_value = .5, max_num_of_copies = 5, num_of_traces_per_freq = 4) {
  raw_intensity_matrix <- c()
  for(i in 1:n_of_sim) {
    temp_intensity <- sim_intensity_once(matrix_size = matrix_size, item_size = item_size, prob = prob, l_value = l_value, max_num_of_copies = max_num_of_copies, num_of_traces_per_freq = num_of_traces_per_freq)
    raw_intensity_matrix <- cbind(raw_intensity_matrix, temp_intensity)
  }
  row_names <- as.data.frame(0:max_num_of_copies)
  names(row_names) <- "Frequency"
  intensity_df <- bind_cols(row_names, data.frame(raw_intensity_matrix)) %>%
      pivot_longer(!Frequency, names_to = "Drop", values_to = "Intensity") %>% select("Frequency", "Intensity")
  return(intensity_df)
}
```

```{r}

df_intensity <- sim_intensity_multiple(1000)
ggplot(df_intensity, aes(x = Intensity, color = factor(Frequency))) + geom_density(show.legend = TRUE) + xlim(-1, 2)
```

## Code for absolute frequency judgments

```{r}
intensity_df <- sim_intensity_multiple(250, matrix_size = 16, l_value = 0.8, max_num_of_copies = 4)
discrim_intensity_df <- intensity_df %>% mutate(freq_judgement = case_when(
  Intensity < 0.17 ~ 0,
  Intensity >= 0.17 & Intensity < 0.67 ~ 1,
  Intensity >= 0.67 & Intensity < 1.33 ~ 2,
  Intensity >= 1.33 & Intensity < 2 ~ 3,
  Intensity >= 2 ~ 4
))

freq_judgment_df <- data.frame(table(factor(discrim_intensity_df$Frequency, levels = 0:4), factor(discrim_intensity_df$freq_judgement, levels = 0:4))) %>% mutate(Freq = Freq/1000) %>% rename(Real_freq = Var1, Freq_judg = Var2, Proportion_of_resp = Freq)


```

```{r}
ggplot(freq_judgment_df, aes(x = Freq_judg, y = Proportion_of_resp, group = Real_freq, color = Real_freq)) + geom_path() + geom_point()

```

I've reproduced the rough shape of the graph, but the values are lower than in Hintzman's (1988) graph. It is also strange that the proportion of correct responses when frequency = 3 is lower than that for frequency = 4. The general trend of lower peaks as frequency_judgment increases is not reflected in my graph.
