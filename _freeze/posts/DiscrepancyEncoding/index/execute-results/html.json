{
  "hash": "d5e36354761aaab6b46a729f7779309b",
  "result": {
    "markdown": "---\ntitle: \"Discrepancy Encoding in MINERVA (Part 1)\"\nauthor: \"Bram Goh\"\ndate: \"2023-03-08\"\ncategories: [code]\nimage: \"\"\n---\n\n\n# Applying discrepancy encoding to frequency judgments\n\nThe goal of this exploration is to look into how the discrepancy encoding assumption introduced in MINERVA-AL (Jamieson et al., 2012) affects Hintzman's (1988) frequency judgment simulations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nset.seed(30)\n\n# Activation function (borrowed from Matt) for a single probe (i.e. a probe vector)\n\nget_activations_3 <- function(probe, mem) {\n  \n  as.numeric(((probe %*% t(mem)) / rowSums(t((probe == 0) * t(mem == 0)) == 0))^3)\n}\n\n# Generate echo (borrowed from Matt)\nget_echo <- function(probe, mem, tau=3, output='intensity') {\n    activations <- get_activations_3(probe,mem)\n    if(output == \"intensity\"){\n      return(sum(activations^tau))\n    }\n    if(output == \"echo\"){\n      weighted_memory <- mem * (activations^tau)  \n      summed_echo <- colSums(weighted_memory)\n      return(summed_echo)\n    }\n    if(output == \"both\"){\n      weighted_memory <- mem * (activations^tau)  \n      summed_echo <- colSums(weighted_memory)\n      model_output <- list(intensity = sum(activations^tau),\n                           echo = summed_echo)\n      return(model_output)\n    }\n    \n}\n\n# Item generation function (borrowed from Matt)\n\ngenerate_item <- function(item_size=20,prob=c(1/3,1/3,1/3)){\n  item <- sample(c(1,0,-1),\n           size = item_size,\n           replace = TRUE,\n           prob = prob)\n  return(item)\n}\n\n# Item matrix (original, before applying learning rate) function\n\ngen_item_matrix <- function(matrix_size = 20, item_size = 20, prob = c(1/3, 1/3, 1/3)) {\n  item_matrix <- t(replicate(n = matrix_size, generate_item(item_size = item_size, prob = prob)))\n  return(item_matrix)\n}\n\n# Form probe matrix i.e. item_matrix multiplied by respective frequencies + 4 more random items\n\ngen_probes <- function(item_matrix, prob = c(1/3, 1/3, 1/3), max_num_of_copies = 5, num_of_traces_per_freq = 4) {\n  freq_multiplier <- rep(1:max_num_of_copies, each = num_of_traces_per_freq)\n  probe_matrix <- c()\n  for(i in 1:length(freq_multiplier)) {\n    current_rows <- matrix(rep(item_matrix[i, ], freq_multiplier[i]), nrow = freq_multiplier[i], ncol = ncol(item_matrix), byrow = TRUE)\n    probe_matrix <- rbind(probe_matrix, current_rows)\n}\n  return(probe_matrix)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Overall simulation function (no discrepancy encoding)\n\nsim_intensity_once <- function(matrix_size = 20, item_size = 20, prob = c(1/3, 1/3, 1/3), l_value = .5, max_num_of_copies = 5, num_of_traces_per_freq = 4) {\n  item_matrix <- gen_item_matrix(matrix_size = matrix_size, item_size = item_size, prob = prob)\n  probe_matrix <- gen_probes(item_matrix, prob = prob, max_num_of_copies = max_num_of_copies, num_of_traces_per_freq = num_of_traces_per_freq)\n\n  # Starting state secondary memory\nmemory <- t(replicate(n = 60, generate_item(item_size = 20, prob = c(1/3, 1/3, 1/3))))\n\n# Caluclating intensities and storing each probe\nintensity_vector <- numeric(length = nrow(probe_matrix))\n  for(i in 1:nrow(probe_matrix)){\n    current_intensity <- get_echo(probe_matrix[i, ], memory, output = \"intensity\")\n    intensity_vector[i] <- current_intensity\n    learning_filter <- sample(c(0, 1), item_size, replace = TRUE, prob = c(1-l_value, l_value))\n    learned_probe <- probe_matrix[i, ] * learning_filter\n    memory[i, ] <- learned_probe\n  }\nintensity_df <- data.frame(intensity_value = intensity_vector)\nreturn(intensity_df)\n}\n\nsim_intensity_multiple <- function(n_of_sim, matrix_size = 20, item_size = 20, prob = c(1/3, 1/3, 1/3), l_value = .5, max_num_of_copies = 5, num_of_traces_per_freq = 4) {\n  full_intensity_df <- data.frame(matrix(0, nrow = sum((1:max_num_of_copies)*4), ncol = n_of_sim))\n  for(i in 1:n_of_sim) {\n    intensity_column <- sim_intensity_once(matrix_size = matrix_size, item_size = item_size, prob = prob, l_value = l_value, max_num_of_copies = max_num_of_copies, num_of_traces_per_freq = num_of_traces_per_freq)\n    full_intensity_df[ , i] <- intensity_column\n  }\n  return(full_intensity_df)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nraw_df_no_de <- sim_intensity_multiple(100)\n\nby_probe_no_de <- data.frame(probe_no = 1:60, intensity = rowMeans(raw_df_no_de))\nggplot(by_probe_no_de, aes(x = probe_no, y = intensity)) + geom_line() + coord_cartesian(ylim = c(-0.01, 0.075)) + scale_x_continuous(breaks = seq(1, 60, 2)) + geom_vline(xintercept = c(5, 13, 25, 41), color = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\nby_freq_no_de <- data.frame(frequency = rep(c(1,2,3,4,5), each = 4), raw_df_no_de) %>% group_by(frequency) %>% summarize_all(mean) %>% pivot_longer(!frequency, names_to = \"Drop\", values_to = \"Intensity\") %>% select(-Drop)\nggplot(by_freq_no_de, aes(x = Intensity, color = factor(frequency))) + geom_density(show.legend = TRUE) + coord_cartesian(xlim = c(-0.01, 0.05))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Overall simulation function (with discrepancy encoding)\n\nsim_intensity_once_de <- function(matrix_size = 20, item_size = 20, prob = c(1/3, 1/3, 1/3), l_value = .5, max_num_of_copies = 5, num_of_traces_per_freq = 4) {\n  item_matrix <- gen_item_matrix(matrix_size = matrix_size, item_size = item_size, prob = prob)\n  probe_matrix <- gen_probes(item_matrix, prob = prob, max_num_of_copies = max_num_of_copies, num_of_traces_per_freq = num_of_traces_per_freq)\n\n  # Starting state secondary memory\nmemory <- t(replicate(n = 60, generate_item(item_size = 20, prob = c(1/3, 1/3, 1/3))))\n\n# Caluclating intensities and storing each probe\nintensity_vector <- numeric(length = nrow(probe_matrix))\n  for(i in 1:nrow(probe_matrix)){\n    current_echo <- get_echo(probe_matrix[i, ], memory, output = \"both\")\n    intensity_vector[i] <- current_echo[[1]]\n    learning_filter <- sample(c(0, 1), item_size, replace = TRUE, prob = c(1-l_value, l_value))\n    current_content <- current_echo[[2]]/max(current_echo[[2]])\n    discrep <- probe_matrix[i, ] - current_content\n    learned_trace <- discrep * learning_filter\n    memory[i, ] <- learned_trace\n  }\nintensity_df <- data.frame(intensity_value = intensity_vector)\nreturn(intensity_df)\n}\n\nsim_intensity_multiple_de <- function(n_of_sim, matrix_size = 20, item_size = 20, prob = c(1/3, 1/3, 1/3), l_value = .5, max_num_of_copies = 5, num_of_traces_per_freq = 4) {\n  full_intensity_df <- data.frame(matrix(0, nrow = sum((1:max_num_of_copies)*4), ncol = n_of_sim))\n  for(i in 1:n_of_sim) {\n    intensity_column <- sim_intensity_once_de(matrix_size = matrix_size, item_size = item_size, prob = prob, l_value = l_value, max_num_of_copies = max_num_of_copies, num_of_traces_per_freq = num_of_traces_per_freq)\n    full_intensity_df[ , i] <- intensity_column\n  }\n  return(full_intensity_df)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nraw_df_with_de <- sim_intensity_multiple_de(100)\n\nby_probe_with_de <- data.frame(probe_no = 1:60, intensity = rowMeans(raw_df_with_de))\nggplot(by_probe_with_de, aes(x = probe_no, y = intensity)) + geom_line() + scale_x_continuous(breaks = seq(1, 60, 2)) + geom_vline(xintercept = c(5, 13, 25, 41), color = \"red\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n\n```{.r .cell-code}\nby_freq_with_de <- data.frame(frequency = rep(c(1,2,3,4,5), each = 4), raw_df_with_de) %>% group_by(frequency) %>% summarize_all(mean) %>% pivot_longer(!frequency, names_to = \"Drop\", values_to = \"Intensity\") %>% select(-Drop)\nggplot(by_freq_with_de, aes(x = Intensity, color = factor(frequency))) + geom_density(show.legend = TRUE) + coord_cartesian(xlim = c(-0.0025, 0.0025))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-2.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}