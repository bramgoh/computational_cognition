{
  "hash": "8fc03c27516951fee380a47d51e4a75e",
  "result": {
    "markdown": "---\ntitle: \"Reproducing Hintzman's MINERVA (Part 5)\"\nauthor: \"Bram Goh\"\ndate: \"2023-02-10\"\ncategories: [code]\nimage: \"\"\n---\n\n\n# Attempting to replicate the schema-abstraction task\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nset.seed(30)\n\n# Initial parameters to set \n\nnum_of_pattern_feat <- 13\nnum_of_name_feat <- 10\nnum_of_trace_feat <- num_of_name_feat + num_of_pattern_feat\nfeat_values <- c(rep(1, 50), rep(-1, 50))\nnum_to_distort <- 4\n\n# Generating prototype function\n  \ngen_proto <- function() {\n   proto <- sample(feat_values, num_of_trace_feat, replace = TRUE)\n   return(proto)\n}\n\n# Generating prototype copies --> yields proto_copies_matrix\n\ngen_proto_copies <- function(input_vector) {\n  full_proto_copies_matrix <- c()\n  for(i in input_vector) {\n    proto_single <- gen_proto()\n    proto_copies <- matrix(rep(proto_single, i), nrow = i, ncol = num_of_trace_feat, byrow = TRUE)\n    full_proto_copies_matrix <- rbind(full_proto_copies_matrix, proto_copies)\n  }\n  return(full_proto_copies_matrix)\n}\n\n# Generating traces in secondary memory with distortion --> yields memory_matrix\n\ngen_secondary_memory <- function(input_vector, proto_copies_matrix) {\n  total_num_traces_in_memory <- sum(input_vector)\n  matrix_of_ones_for_name <- matrix(1, nrow = total_num_traces_in_memory, ncol = num_of_name_feat)\n  matrix_of_pattern_distort <- t(replicate(n = total_num_traces_in_memory, sample(c(rep(1, num_of_pattern_feat - num_to_distort), rep(-1, num_to_distort)), num_of_pattern_feat)))\n  distort_filter <- cbind(matrix_of_ones_for_name, matrix_of_pattern_distort)\n  distorted_memories <- proto_copies_matrix * distort_filter\nreturn(distorted_memories)\n}\n  \n# Extracting unique prototypes (one for each category) --> yields proto_matrix\n\nextract_unique_proto <- function(input_vector, proto_copies_matrix) {\n  full_unique_proto_matrix <- c()\n  row_counter <- 0\n  for(i in input_vector) {\n    proto_current <- proto_copies_matrix[row_counter + 1, ]\n    full_unique_proto_matrix <- rbind(full_unique_proto_matrix, proto_current)\n    row_counter <- row_counter + i\n  }\nreturn(full_unique_proto_matrix)\n}\n\n# Generating probes from prototypes --> yields probe_matrix\n\ngen_probes_from_proto <- function(proto_matrix) {\n  matrix_of_ones_for_name <- matrix(1, nrow = nrow(proto_matrix), ncol = num_of_name_feat)\n  matrix_of_zeroes_for_pattern <- matrix(0, nrow = nrow(proto_matrix), ncol = num_of_pattern_feat)\n  probe_filter <- cbind(matrix_of_ones_for_name, matrix_of_zeroes_for_pattern)\n  probe_unique_matrix <- proto_matrix * probe_filter\n  return(probe_unique_matrix)\n}\n\n# Echo activation function --> yields activations_matrix\ncalc_echo_activations <- function(probe_matrix, memory_matrix) {\nfull_probe_activations_matrix <- c()\n  for(probe in 1:nrow(probe_matrix)) {\n    all_activations_for_each_probe <- c()\n    for(memory in 1:nrow(memory_matrix)) {\n      num_of_relevant_features <- 0\n      similarity_temp <- 0\n      for(feat in 1:num_of_trace_feat) {\n        current_product <- probe_matrix[probe, feat] * memory_matrix[memory, feat]\n        similarity_temp <- similarity_temp + current_product\n          if(probe_matrix[probe, feat] != 0 & memory_matrix[memory, feat] != 0) {\n            num_of_relevant_features <- num_of_relevant_features + 1\n          }\n    }\n    trace_similarity <- similarity_temp/num_of_relevant_features\n    trace_activation <- trace_similarity ^ 3\n    all_activations_for_each_probe <- c(all_activations_for_each_probe, trace_activation)\n  }\nfull_probe_activations_matrix <- rbind(full_probe_activations_matrix, all_activations_for_each_probe)\n}\nreturn(full_probe_activations_matrix)\n}\n\n# Echo intensity function --> yields intensity_matrix\ncalc_echo_intensity <- function(activations_matrix) {\n  full_intensity_matrix <- c()\n  for(probe in 1:nrow(activations_matrix)) {\n    echo_intensity_for_probe <- sum(activations_matrix[probe, ])\n    full_intensity_matrix <- c(full_intensity_matrix, echo_intensity_for_probe) \n  }\n  return(full_intensity_matrix)\n}\n\n# Echo content function --> yields content_matrix\n\ncalc_echo_content <- function(activations_matrix, memory_matrix) {\n  full_echo_content_matrix <- c()\n  for(probe in 1:nrow(activations_matrix)) {\n    echo_content_for_each_probe <- c()\n    for(feat in 1:num_of_trace_feat){\n      content_temp <- 0\n        for(memory in 1:nrow(memory_matrix)) {\n          current_product <- activations_matrix[probe, memory] * memory_matrix[memory, feat]\n          content_temp <- content_temp + current_product\n        }\n      echo_content_for_each_probe <- c(echo_content_for_each_probe, content_temp)\n    }\n    full_echo_content_matrix <- rbind(full_echo_content_matrix, echo_content_for_each_probe)\n  }\n  return(full_echo_content_matrix)\n}\n\n# Calculating prototype-echo correlation --> yields correlation_matrix\n\ncalc_proto_echo_corr <- function(proto_matrix, content_matrix) {\n  full_correlation_matrix <- c()\n  for(proto in 1:nrow(proto_matrix)) {\n    correlation_current <- cor(proto_matrix[proto, ], content_matrix[proto, ])\n    full_correlation_matrix <- c(full_correlation_matrix, correlation_current)\n  }\n  return(full_correlation_matrix)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Makes all name features in secondary memory empty --> yields nameless_memory_matrix\nremove_name_feat_from_memory <- function(memory_matrix) {\n  zero_matrix <- matrix(0, nrow = nrow(memory_matrix), ncol = num_of_name_feat)\n  one_matrix <- matrix(1, nrow = nrow(memory_matrix), ncol = num_of_pattern_feat)\n  remove_name_filter <- cbind(zero_matrix, one_matrix)\n  memory_matrix_without_name <- memory_matrix * remove_name_filter\n  return(memory_matrix_without_name)\n}\n\n# Generates old exemplars already in secondary memory (probe a)\nextract_old_exemplars <- function(input_vector, nameless_memory_matrix) {\n  full_old_exemp_matrix <- c()\n  row_counter <- 0\n  for(i in input_vector) {\n    old_exemp_current <- nameless_memory_matrix[row_counter + 1, ]\n    full_old_exemp_matrix <- rbind(full_old_exemp_matrix, old_exemp_current)\n    row_counter <- row_counter + i\n  }\n  return(full_old_exemp_matrix)\n}\n\n# Extracts prototype matrix with empty name features (probe b) --> yields nameless_proto_matrix\n\nextract_unique_proto_without_names <- function(input_vector, proto_copies_matrix) {\n  \n  unique_protos <- extract_unique_proto(input_vector, proto_copies_matrix)\n  zero_matrix <- matrix(0, nrow = nrow(unique_protos), ncol = num_of_name_feat)\n  one_matrix <- matrix(1, nrow = nrow(unique_protos), ncol = num_of_pattern_feat)\n  remove_name_filter <- cbind(zero_matrix, one_matrix)\n  protos_without_name <- unique_protos * remove_name_filter\n  return(protos_without_name)\n}\n\n# Generates new low-distorted exemplars (probe c)\ngen_new_low_distort_exemp <- function(nameless_proto_matrix) {\n  \n  vector_of_ones_for_name <- rep(1, num_of_name_feat)\n  vector_of_pattern_distort <- sample(c(rep(1, num_of_pattern_feat- 2), rep(-1, 2)), num_of_pattern_feat)\n  distort_filter <- c(vector_of_ones_for_name, vector_of_pattern_distort)\n  \n  full_new_low_distort_matrix <- c()\n  for(proto in 1:nrow(nameless_proto_matrix)) {\n    current_new_low_distort <- nameless_proto_matrix[proto, ] * distort_filter\n    full_new_low_distort_matrix <- rbind(full_new_low_distort_matrix, current_new_low_distort)\n  }\nreturn(full_new_low_distort_matrix)\n  }\n\n# Generates new high-distorted exemplars (probe d)\ngen_new_high_distort_exemp <- function(nameless_proto_matrix) {\n  \n  vector_of_ones_for_name <- rep(1, num_of_name_feat)\n  vector_of_pattern_distort <- sample(c(rep(1, num_of_pattern_feat- 4), rep(-1, 4)), num_of_pattern_feat)\n  distort_filter <- c(vector_of_ones_for_name, vector_of_pattern_distort)\n  \n  full_new_high_distort_matrix <- c()\n  for(proto in 1:nrow(nameless_proto_matrix)) {\n    current_new_high_distort <- nameless_proto_matrix[proto, ] * distort_filter\n    full_new_high_distort_matrix <- rbind(full_new_high_distort_matrix, current_new_high_distort)\n  }\nreturn(full_new_high_distort_matrix)\n  }\n\n# Generates random pattern (probe e)\ngen_random_patterns <- function(nameless_proto_matrix) {\n  full_random_pattern_matrix <- c()\n  for(proto in 1:nrow(nameless_proto_matrix)) {\n    name_vector <- nameless_proto_matrix[proto, 1:num_of_name_feat]\n    random_pattern_feat_vector <- sample(feat_values, num_of_pattern_feat, replace = TRUE)\n    current_random_vector <- c(name_vector, random_pattern_feat_vector)\n    full_random_pattern_matrix <- rbind(full_random_pattern_matrix, current_random_vector)\n  }\n  return(full_random_pattern_matrix)\n}\n\n# Applies forgetting to traces in secondary memory\nforgetting_cycle <- function(nameless_memory_matrix, f_value) {\n  memory_matrix_post_forgetting <- c()\n  for(trace in 1:nrow(nameless_memory_matrix)) {\n    forget_filter <- rbinom(num_of_trace_feat, 1, 1 - f_value)\n    current_forgotten_memory <- nameless_memory_matrix[trace, ] * forget_filter\n    memory_matrix_post_forgetting <- rbind(memory_matrix_post_forgetting, current_forgotten_memory)\n  }\n  return(memory_matrix_post_forgetting)\n}\n\n# Extracts only name features from prototypes --> yields category_names\nextract_category_names <- function(input_vector, proto_copies_matrix) {\n  unique_protos <- extract_unique_proto(input_vector, proto_copies_matrix)\n  cat_names <- unique_protos[ , 1:num_of_name_feat]\n  return(cat_names)\n}\n\n# Extracts only name features from echo content --> yields echo_names\nextract_echo_content_name_feat <- function(content_matrix) {\n  echo_content_name <- content_matrix[ , 1:num_of_name_feat]\n}\n\n# Computes category name-echo content name correlation for each probe and assigns echo to category --> yields category_assign_vector\nassign_category_for_each_echo <- function(category_names, echo_names) {\ncategory_for_each_echo <- c()\nfor(e_name in 1:nrow(echo_names)) {\n  cat_echo_name_cor <- c()\n  for(c_name in 1:nrow(category_names)) {\n    current_cor <- cor(echo_names[e_name, ], category_names[c_name, ])\n    cat_echo_name_cor <- c(cat_echo_name_cor, current_cor)\n  }\n  if(max(cat_echo_name_cor) < 0) {\n   current_answer <- -9999\n  } else {\n    current_answer_temp <- which(cat_echo_name_cor == max(cat_echo_name_cor))\n    if(length(current_answer_temp) > 1) {\n    current_answer <- sample(current_answer_temp, 1)\n    } else {\n    current_answer <- current_answer_temp\n    }\n  }\n  category_for_each_echo <- c(category_for_each_echo, current_answer)\n}\nreturn(category_for_each_echo)\n}\n\ncheck_assign_accuracy <- function(category_assign_vector, input_vector, num_types_of_probe){\n  accuracy_vector <- category_assign_vector == rep(1:length(input_vector), num_types_of_probe)\n  return(accuracy_vector)\n  }\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nschema_abstraction <- function(input_vector, num_types_of_probe) {\n  proto_copies_matrix <- gen_proto_copies(input_vector)\n  secondary_memory <- gen_secondary_memory(input_vector, proto_copies_matrix)\n  \n  nameless_memory_matrix <- remove_name_feat_from_memory(secondary_memory)\n  \n  old_exemplars <- extract_old_exemplars(input_vector, nameless_memory_matrix)\n  nameless_proto_matrix <- extract_unique_proto_without_names(input_vector, proto_copies_matrix)\n  new_low_distorts <- gen_new_low_distort_exemp(nameless_proto_matrix)\n  new_high_distorts <- gen_new_high_distort_exemp(nameless_proto_matrix)\n  random_patterns <- gen_random_patterns(nameless_proto_matrix)\n  \n  diverse_probes <- rbind(old_exemplars, nameless_proto_matrix, new_low_distorts, new_high_distorts, random_patterns)\n  activations_matrix <- calc_echo_activations(diverse_probes, secondary_memory)\n  content_matrix <- calc_echo_content(activations_matrix, secondary_memory)\n  \n  category_names <- extract_category_names(input_vector, proto_copies_matrix)\n  echo_names <- extract_echo_content_name_feat(content_matrix)\n  category_vector <- assign_category_for_each_echo(category_names, echo_names)\n  accuracy_vector <- check_assign_accuracy(category_vector, input_vector, num_types_of_probe)\n  return(accuracy_vector)\n}\n\nsimulate_schema_abstraction <- function(input_vector, num_types_of_probe, num_of_simulations, column_names) {\n  results_matrix <- t(replicate(num_of_simulations, schema_abstraction(input_vector, num_types_of_probe)))\n  results_df <- data.frame(results_matrix)\n  colnames(results_df) <- column_names\n  return(results_df)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Test simulating 10 subjects\n\ndf_col_names <- c(\"old_exemp_1\", \"old_exemp_2\", \"old_exemp_3\", \"proto_1\", \"proto_2\", \"proto_3\", \"low_dist_1\", \"low_dist_2\", \"low_dist_3\", \"high_dist_1\", \"high_dist_2\", \"high_dist_3\", \"random_1\", \"random_2\", \"random_3\")\nhintz_input <- c(3, 6, 9)\nschema_sim <- simulate_schema_abstraction(hintz_input, 5, 10, df_col_names)\n```\n:::\n\n\nThings I'm unsure about:\n\n-   The probes contain empty name features, right?\n\n-   The forgetting affects all features, including name features, right?\n\n-   Does it matter which old exemplar I choose? (I've just chosen the first of each category)\n\nThere's something wrong with the code, especially when the number of simulations gets too high (e.g. 100). It seems the problem lies with the assign_category_for_each_echo function; there could be a function that is occasionally turning up an NA value?\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}