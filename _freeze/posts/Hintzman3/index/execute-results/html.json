{
  "hash": "561b22c18883bd321832f3dfb4d4d27b",
  "result": {
    "markdown": "---\ntitle: \"Reproducing Hintzman's MINERVA (Part 3)\"\nauthor: \"Bram Goh\"\ndate: \"2023-02-01\"\ncategories: [code]\nimage: \"image.jpg\"\n---\n\n\n# First (completed) attempt at the Abstraction exercise\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nset.seed(30)\nnum_feat <- 13\nnum_name <- 10\nnum_trace <- num_name + num_feat\nvalues <- c(rep(1, 50), rep(-1, 50))\n\nempty_feat <- rep(0, num_feat)\n\nabstraction <- function(num_a, num_b, num_c, num_distort) {\n\n# Generating prototype\n  \ngen_proto <- function() {\n   proto <- sample(values, num_trace, replace = TRUE)\n   return(proto)\n}\n\nproto_a <- gen_proto()\nproto_b <- gen_proto()\nproto_c <- gen_proto()\n\n# Generating exemplars with distortions\n\ngen_exemp <- function(proto, num_exemp, num_distort) {\n  \n  proto_copies <- matrix(rep(proto, num_exemp), nrow = num_exemp, ncol = num_trace, byrow = TRUE)\n  \n  name_matrix_ones <- matrix(1, nrow = num_exemp, ncol = num_name)\n  feat_matrix_distort <- t(replicate(n = num_exemp, sample(c(rep(1, num_feat - num_distort), rep(-1, num_distort)), num_feat)))\n  distort_filter <- cbind(name_matrix_ones, feat_matrix_distort)\n\n  exemp <- proto_copies * distort_filter\n  return(exemp)\n}\n  \n# Generating traces and probes\na <- gen_exemp(proto_a, num_a, num_distort)\nprobe_a <- c(a[1, 1:num_name], empty_feat)\nb <- gen_exemp(proto_b, num_b, num_distort)\nprobe_b <- c(b[1, 1:num_name], empty_feat)\nc <- gen_exemp(proto_c, num_c, num_distort)\nprobe_c <- c(c[1, 1:num_name], empty_feat)\n  \nsm <- rbind(a, b, c)\n  \n# Echo activation function\necho_activation <- function(probe, sec_mem) {\n  e_activs <- c()\n      for(i in 1:nrow(sec_mem)){\n          n_rel <- 0\n          temp_sim <- 0\n              for(j in 1:num_trace){\n                   current <- probe[j] * sec_mem[i, j]\n                   temp_sim <- current + temp_sim\n                          if(probe[j] != 0 & sec_mem[i, j] != 0) {\n                                     n_rel <- n_rel + 1\n      }\n}\ntrace_sim <- temp_sim/n_rel\ntrace_act <- trace_sim^3\ne_activs <- c(e_activs, trace_act)\n      }\n  return(e_activs)\n}\n\nactivs_a <- echo_activation(probe_a, sm)\nactivs_b <- echo_activation(probe_b, sm)\nactivs_c <- echo_activation(probe_c, sm)\n\n# Echo content function\n\necho_content <- function(acts, sec_mem) {\n  e_cont <- c()\n  for(j in 1:num_trace){\n    temp_cont <- 0\n    for(i in 1:nrow(sec_mem)){\n      current <- acts[i] * sec_mem[i, j]\n      temp_cont <- current + temp_cont\n    }\n    e_cont <- c(e_cont, temp_cont)\n  }\n  return(e_cont)\n}\n\n# Calculating echo intensity and probe-echo correlations\necho_a <- round(echo_content(activs_a, sm), 3)\ncor_a <- cor(proto_a, echo_a)\nint_a <- sum(activs_a)\necho_b <- round(echo_content(activs_b, sm), 3)\ncor_b <- cor(proto_b, echo_b)\nint_b <- sum(activs_b)\necho_c <- round(echo_content(activs_c, sm), 3)\ncor_c <- cor(proto_c, echo_c)\nint_c <- sum(activs_c)\n\ndf <- data.frame(corr = c(cor_a, cor_b, cor_c), intensity = c(int_a, int_b, int_c))\nrownames(df) <- c(\"catA\", \"catB\", \"catC\")\nreturn(df)\n}\n```\n:::\n\n\nI had to rework the code so that the prototypes were actually the basis for the distorted exemplars. The code seems to work and generate the intended outcomes, but I'll need to verify it with Matt.\n\nI'll also need to ask if there is a way to return multiple outputs from this function i.e. for each of the 3 categories, I'll need the prototype, the echo, the prototype-echo correlation, and the echo intensity. Perhaps returning a list would work?\n\nThe next step is to produce graphs like the ones in Hintzman (1986) comparing prototypes to echos.\n\n![](images/Screenshot%202023-02-01%20at%2010.24.41%20AM.png)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}