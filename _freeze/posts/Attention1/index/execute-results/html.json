{
  "hash": "db66578156de5c4c5b98324347a71bc8",
  "result": {
    "markdown": "---\ntitle: \"A MINERVA model for attention\"\nauthor: \"Bram Goh\"\ndate: \"2023-02-24\"\ncategories: [code]\nimage: \"Stroop1.png\"\n---\n\n\n# Applying MINERVA to the Stroop task\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(30)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nlibrary(gtools)\nlibrary(bench)\n\ncolors <- c(\"red\", \"yellow\", \"green\", \"blue\")\n\nnum_of_feat <- 10\nnum_of_congruent_trials <- 48\nnum_of_incongruent_trials <- 48\nattention_dampeners <- c(.5, .6, .7, .8, .9, 1)\ncon_trials_per_color <- num_of_congruent_trials/length(colors)\ncongruent_answer_column <- c()\nfor(i in 1:length(colors)){\n  current_correct_answer <- rep(colors[i], con_trials_per_color)\n  congruent_answer_column <- c(congruent_answer_column, current_correct_answer)\n}\n\nincon_permuts <- permutations(length(colors), 2)\nnum_of_repeat_incon_trials <- num_of_incongruent_trials/nrow(incon_permuts)\nincongruent_answer_column <- c()\nfor(i in 1:nrow(incon_permuts)){\n  current_correct_answer <- rep(colors[incon_permuts[i, 1]], num_of_repeat_incon_trials)\n  incongruent_answer_column <- c(incongruent_answer_column, current_correct_answer)\n}\n\nfull_correct_answer_column <- c(congruent_answer_column, incongruent_answer_column)\n\ngen_color <- function() {\n  color <- sample(c(1, 0, -1), num_of_feat, replace = TRUE, prob = c(1/3, 1/3, 1/3))\n  return(color)\n}\n\npatterns <- c()\nfor(i in 1:length(colors)) {\n  temp_pattern <- gen_color()\n  patterns <- rbind(patterns, temp_pattern)\n}\n\nrow.names(patterns) <- colors\nblank <- numeric(length = num_of_feat)\n\nmemory <- c()\nfor(i in 1:nrow(patterns)) {\n  ink_set <- c(patterns[i, ], blank, patterns[i, ], blank)\n  word_set <- c(blank, patterns[i, ], blank, patterns[i, ])\n  congruent_set <- c(patterns[i, ], patterns[i, ], patterns[i, ], patterns[i, ])\n  memory <- rbind(memory, ink_set, word_set, congruent_set)\n}\nfull_memory <- rbind(memory, memory, memory, memory, memory)\n\n\ncongruent_probes <- c()\nfor(i in 1:nrow(patterns)){\n  current_trials <- c(patterns[i, ], patterns[i, ], blank, blank)\n  current_combi <- matrix(current_trials, nrow = con_trials_per_color, ncol = length(current_trials), byrow=TRUE)\n  congruent_probes <- rbind(congruent_probes, current_combi)\n}\n\n\nincongruent_probes <- c()\nfor(i in 1:nrow(incon_permuts)){\n  current_trials <- c(patterns[incon_permuts[i, 1], ], patterns[incon_permuts[i, 2], ], blank, blank)\n  current_combi <- matrix(current_trials, nrow = num_of_repeat_incon_trials, ncol = length(current_trials), byrow = TRUE)\n  incongruent_probes <- rbind(incongruent_probes, current_combi)\n}\n\nfull_probes <- rbind(congruent_probes, incongruent_probes)\n\n# Activation function for single probe (borrowed from Matt)\nget_activations_3 <- function(probe, mem) {\n  \n  as.numeric(((probe %*% t(mem)) / rowSums(t((probe == 0) * t(mem == 0)) == 0))^3)\n}\n\n# Function for calculating echo content for single probe (modified from previous exercise)\ncalc_echo_content_for_each_probe <- function(activations_vector, memory_matrix) {\n    echo_content_for_each_probe <- c()\n    for(feat in 1:ncol(memory_matrix)){\n      content_temp <- 0\n        for(memory in 1:nrow(memory_matrix)) {\n          current_product <- activations_vector[memory] * memory_matrix[memory, feat]\n          content_temp <- content_temp + current_product\n        }\n      echo_content_for_each_probe <- c(echo_content_for_each_probe, content_temp)\n  }\n  return(echo_content_for_each_probe)\n}\n\n# Function for generating dampened content\n\ndampen_distractor <- function(probe_content){\n  non_zero <- FALSE\n  while(non_zero == FALSE){\n  dampen_value <- sample(attention_dampeners, 1)\n  attention_dampening_filter <- c(rep(1, num_of_feat*3), sample(c(0, 1), num_of_feat, replace = TRUE, prob = c(1 - dampen_value, dampen_value)))\n   dampened_content <- probe_content * attention_dampening_filter\n   if(sum(abs(dampened_content[(num_of_feat*3+1):(num_of_feat*4)])) != 0){\n     non_zero <- TRUE\n   }\n  }\n     dampened_output <- c(dampened_content, dampen_value)\n   return(dampened_output)\n}\n\n# Function for one Stroop trial (dampening mechanism)\nstroop_one_trial_dampen <- function(probe_vector, memory_matrix, color_patterns){\n # Attention dampening filter dampens attention to words (in favor of ink color)\n  success <- FALSE\n  start_time <- Sys.time()\n  while(success == FALSE) {\n  probe_activation <- get_activations_3(probe_vector, memory_matrix)\n   probe_content <- calc_echo_content_for_each_probe(probe_activation, memory_matrix)\n   dampened_output <- dampen_distractor(probe_content)\n   dampened_content <- dampened_output[1:(num_of_feat*4)]\n   dampen_value <- dampened_output[num_of_feat*4 + 1]\n   trial_ink_corrs <- c()\n   trial_word_corrs <- c()\n   for(j in 1:nrow(color_patterns)){\n    ink_corr <- cor(color_patterns[j, ], dampened_content[(num_of_feat*2 + 1) : (num_of_feat*3)])\n    if(is.na(ink_corr)){\n      ink_corr <- 0\n    }\n    word_corr <- cor(color_patterns[j, ], dampened_content[(num_of_feat*3 + 1) : (num_of_feat*4)])\n    if(is.na(word_corr)){\n      word_corr <- 0\n    }\n    trial_ink_corrs <- c(trial_ink_corrs, ink_corr)\n    trial_word_corrs <- c(trial_word_corrs, word_corr)\n }\n   if(max(trial_ink_corrs) >= max(trial_word_corrs)){\n     response <- color_patterns[which.max(trial_ink_corrs), ]\n   } else {\n     response <- color_patterns[which.max(trial_word_corrs), ]\n   }\n   accuracy <- all(response == probe_vector[1:num_of_feat])\n   success <- accuracy == TRUE\n  }\n  end_time <- Sys.time()\n  if(all(probe_vector[1:num_of_feat] == probe_vector[(num_of_feat+1):(num_of_feat*2)])){\n    condition <- \"congruent\"\n  } else {\n    condition <- \"incongruent\"\n  }\n  trial_outcome <- data.frame(condition = condition, dampener = dampen_value, time_elapsed = end_time - start_time, accuracy = accuracy)\n   return(trial_outcome)\n}\n\n# Function for full Stroop task simulation (dampening mechanism)\nfull_stroop_sim_dampen <- function(probe_matrix, memory_matrix, color_patterns) {\n  all_outcomes <- c()\n  for(i in 1:nrow(probe_matrix)){\n    trial_outcome <- stroop_one_trial_dampen(probe_matrix[i, ], memory_matrix, color_patterns)\n    all_outcomes <- bind_rows(all_outcomes, trial_outcome)\n  }\n  all_outcomes <- all_outcomes %>% mutate(correct_answer = full_correct_answer_column)\n  return(all_outcomes)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstroop_results <- data.frame()\n\nfor(i in 1:100){\n  current_participant <- full_stroop_sim_dampen(full_probes, full_memory, patterns)\n  stroop_results <- bind_rows(stroop_results, current_participant)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstroop_means <- stroop_results %>% group_by(condition, dampener) %>% summarize(mean_dur = mean(time_elapsed))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'condition'. You can override using the\n`.groups` argument.\n```\n:::\n\n```{.r .cell-code}\nggplot(stroop_means, aes(x = dampener, y = mean_dur, color = condition)) + geom_line()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nDon't know how to automatically pick scale for object of type difftime. Defaulting to continuous.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\nThe trend for the congruent condition makes sense, since the amount of dampening of the distractor should not influence performance, since the target and distractor do not compete for the response. However, for the incongruent condition, it doesn't really make sense that the more the distractors is dampened, the longer it takes to give the correct response. In fact, that's the opposite of what we would expect.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}