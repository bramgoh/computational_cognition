{
  "hash": "011cbce081fc20770655ae223501584b",
  "result": {
    "markdown": "---\ntitle: \"A MINERVA model for attention (Part 2)\"\nauthor: \"Bram Goh\"\ndate: \"2023-02-28\"\ncategories: [code]\nimage: \"Stroop_equal.png\"\n---\n\n::: {.cell}\n\n```{.r .cell-code}\n# Define Functions\n\n# function to generate a single item\ngenerate_item <- function(size=20,prob=c(1/3,1/3,1/3)){\n  item <- sample(c(1,0,-1),\n           size = size,\n           replace = TRUE,\n           prob = prob)\n  return(item)\n}\n\n# compute activations\nget_activations <- function(probe,memory){\n   as.numeric(((probe %*% t(memory)) / rowSums(t((probe == 0) * t(memory == 0)) == 0)))\n}\n\n# generate echo\nget_echo <- function(probe, mem, tau=3, output='intensity') {\n    activations <- get_activations(probe,mem)\n    if(output == \"intensity\"){\n      return(sum(activations^tau))\n    }\n    if(output == \"echo\"){\n      weighted_memory <- mem * (activations^tau)  \n      summed_echo <- colSums(weighted_memory)\n      return(summed_echo)\n    }\n    if(output == \"both\"){\n      weighted_memory <- mem * (activations^tau)  \n      summed_echo <- colSums(weighted_memory)\n      model_output <- list(intensity = sum(activations^tau),\n                           echo = summed_echo)\n      return(model_output)\n    }\n    \n}\n\nget_cosine_sim <- function(echo_features, response_matrix) {\n  similarity_df <- data.frame()\n  \n  for(i in 1:nrow(response_matrix)){\n    current_sim <- cosine(echo_features, response_matrix[i, ])\n    similarity_df <- rbind(similarity_df, current_sim)\n  }\n  names(similarity_df) <- \"similarity\"\n  row.names(similarity_df) <- c(\"red\", \"green\", \"blue\", \"yellow\")\n  return(similarity_df)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ──\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ ggplot2 3.3.6     ✔ purrr   0.3.4\n✔ tibble  3.1.7     ✔ dplyr   1.0.9\n✔ tidyr   1.2.0     ✔ stringr 1.4.0\n✔ readr   2.1.2     ✔ forcats 0.5.1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n\n```{.r .cell-code}\nlibrary(lsa)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: SnowballC\n```\n:::\n\n```{.r .cell-code}\n# Generate Stroop dataframe\n\ncongruent_items <- tibble(word = c(\"red\",\"green\",\"blue\",\"yellow\"),\n                          color = c(\"red\",\"green\",\"blue\",\"yellow\"),\n                          response = c(\"red\",\"green\",\"blue\",\"yellow\"),\n                          congruency = rep(\"con\",4))\n\nincongruent_items <- tibble(word = c(\"red\",\"red\",\"red\",\n                                     \"green\",\"green\",\"green\",\n                                     \"blue\",\"blue\",\"blue\",\n                                     \"yellow\",\"yellow\",\"yellow\"),\n                          color = c(\"green\",\"blue\",\"yellow\",\n                                    \"red\",\"blue\",\"yellow\",\n                                    \"red\",\"green\",\"yellow\",\n                                    \"red\",\"green\",\"blue\"),\n                          response = c(\"green\",\"blue\",\"yellow\",\n                                    \"red\",\"blue\",\"yellow\",\n                                    \"red\",\"green\",\"yellow\",\n                                    \"red\",\"green\",\"blue\"),\n                          congruency = rep(\"inc\",12))\n\n\n\ntraining_trials <- congruent_items            \n\nstroop_trials <- congruent_items %>% \n  slice(rep(1:n(),each=3)) %>%\n  rbind(incongruent_items) %>%\n  slice(sample(1:n())) %>%\n  slice(rep(1:n(),each=2))\n\n# Function for simulating multiple subjects on Stroop task\n\nsim_multiple_stroop <- function(training, stroop, n_of_sim) {\n  all_sub_results <- data.frame()\n\n  for(i in 1:n_of_sim){\n# Make vector representations\n\nword <- t(replicate(4, generate_item(size=20,prob=c(1/3,1/3,1/3))))\nrow.names(word) <- c(\"red\",\"green\",\"blue\",\"yellow\")\n\ncolor <- t(replicate(4, generate_item(size=20,prob=c(1/3,1/3,1/3))))\nrow.names(color) <- c(\"red\",\"green\",\"blue\",\"yellow\")\n\nresponse <- t(replicate(4, generate_item(size=20,prob=c(1/3,1/3,1/3))))\nrow.names(response) <- c(\"red\",\"green\",\"blue\",\"yellow\")\n\n## Trial constructor\n\nminerva_trials <- function(df,vec_length=20){\n  minerva_matrix <- matrix(0,nrow = dim(df)[1],ncol=vec_length*3)\n  \n  for(i in 1:dim(df)[1]){\n    minerva_matrix[i,] <- c(word[df[i,]$word, ], color[df[i,]$color, ], response[df[i,]$response, ])\n  }\n  \n  return(minerva_matrix)\n}\n\ntraining_matrix <- minerva_trials(training)\ntrial_matrix <- minerva_trials(stroop)\n\n## run model\n\nsubject_results <- data.frame()\n\nmemory <- training_matrix\n\nfor(i in 1:dim(trial_matrix)[1]){\n  \n  probe <- c(trial_matrix[i,1:40],rep(0,20))\n  model_output <- get_echo(probe, memory, tau=3, output = \"both\")\n  similarities <- get_cosine_sim(model_output$echo[41:60], response)\n  memory <- rbind(memory,trial_matrix[i,])\n  \n  trial_data <- data.frame(red = similarities['red', ],\n                           green = similarities['green', ],\n                           blue = similarities['blue', ],\n                           yellow = similarities['yellow', ],\n                           intensity = model_output$intensity,\n                           max_sim = row.names(similarities)[which.max(similarities$similarity)],\n                           max_sim_num = max(similarities),\n                           coactivation = max(similarities)/(sum(abs(similarities))))\n  \n  subject_results <- rbind(subject_results,trial_data)\n}\n\nrow.names(subject_results) <- 1:dim(subject_results)[1]\n\n## analyze data \n\none_sub <- cbind(stroop_trials,subject_results)\n\none_sub <- one_sub %>%\n  mutate(correct = response == max_sim)\n\nsummarized_one_sub <- one_sub %>%\n  group_by(congruency) %>%\n  summarize(mean_correct = mean(correct),\n            mean_max = mean(max_sim_num),\n            mean_coactivation = mean(coactivation))\nall_sub_results <- rbind(all_sub_results, summarized_one_sub)\n  }\nreturn(all_sub_results)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Equal number of congruent and incongruent trials\n\nequal_sim <- sim_multiple_stroop(training_trials, stroop_trials, 100)\nggplot(equal_sim, aes(x = congruency, y = mean_max)) + geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# 75% congruent and 25% incongruent trials\n\nstroop_75_25 <- congruent_items %>% \n  slice(rep(1:n(),each=9)) %>%\n  rbind(incongruent_items) %>%\n  slice(sample(1:n()))\n\nmore_congruent_sim <- sim_multiple_stroop(training_trials, stroop_75_25, 100)\nggplot(more_congruent_sim, aes(x = congruency, y = mean_max)) + geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-2.png){width=672}\n:::\n\n```{.r .cell-code}\n# 25% congruent and 75% incongruent trials\n\nrep_incongruent <- incongruent_items %>% slice(rep(1:n(), each = 3))\nstroop_25_75 <- congruent_items %>%\n  slice(rep(1:n(),each=3)) %>%\n  rbind(rep_incongruent) %>%\n  slice(sample(1:n()))\n\nmore_incongruent_sim <- sim_multiple_stroop(training_trials, stroop_25_75, 100)\nggplot(more_incongruent_sim, aes(x = congruency, y = mean_max)) + geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-3.png){width=672}\n:::\n:::\n\n\nWhy is the Stroop effect stronger when there is an equal proportion of congruent and incongruent trials than when there are more congruent than incongruent trials?\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}